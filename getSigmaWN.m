% get 90% CL limits on WIMP-nucleon elastic scattering cross section
% 
%
% 131017 pfs - code base is several years old. cleaned up and committing for LUX use
%              max gap code now extensively verified against theorists and CDMS folks

graphik = 0 % set to the mass value for the plot you wish to see
granularityInSigma_n = 0.99;


%% set the experiment conditions below and define the case here
ees = [6000] % LZ S2
%ees = 300 % LUX check up

for ee=ees
	clear m_chi sigma_n0
	%% set some general defaults
		% options for velocity integration:
			% 'JKG_w_escape'			-- JKG eq 8.16, with escape v accounted for from LS 3.13
			% 'explicit_JKG_w_escape'	-- JKG eq 8.15, with escape v accounted for from LS 3.13
			% 'PRD_74_043531_2006'		-- default
			C.velocityIntegrationMethod = 'PRD_74_043531_2006';
		% other defaults
		C.accountForInelasticNucleusScattering = 0;
		C.Er_cutoff = 3; % keV, hard cutoff

	%%%%%%%%%%%%%%%%%%%%%%%%% Fundamental constants
		%C.G_F = 1.16639*1e-5; % in GeV^-2 % this is GF/(hbarc)^3
		C.mp = 0.938; % % proton Mass, GeV
		C.hbar = 6.5822*1e-25; % in GeV * s
		C.c = 2.9979e10; % cm/s
		C.N_0 = 6.022e23; % Avogadro number, atoms/mol
	%%%%%%%%%%%%%%%%%%%%%%%%% Astrophysical constants
		C.rho_chi = 0.3; % GeV cm-3 c-2
		C.v_0 = 220/3e5; % velocity dispersion of isotropic MB distribution
		% rotational speed for LSR is similar to M-B velocity dispersion -- see getDMvelocityDistribution.m
		switch 100
		case 1
			C.v_esc = 550/3e5; % units of c -- following PRD 79 043513 (2009)
		case 100
			C.v_esc = 544/3e5; % units of c -- following PRD 79 043513 (2009)
		end
	%%%%%%%%%%%%%%%%%%%%%%%%% Nuclear physics constants
		C.f_p = 1;
		C.f_n = 1;
	%%%%%%%%%%%%%%%%%%%%%%%%% the energy points for the expected spectrum
		C.dEr = 0.01;
		C.Er = C.dEr:C.dEr:40;
	
	switch ee
	case 1
		experiment='XENON10';analysis='PRL';
		limitMethod='maxGap';
		whichleff = 'flat19';
		S{ee}.col=[1 0 0]; S{ee}.sty = '-'; S{ee}.lw = 0.5; S{ee}.leg = '';
	
	case 24 % FINAL for paper
		experiment='XENON10';analysis='WS2';
		limitMethod='pmax';
		limitMethod='maxGap'; % testing
		C.eta = ones(size(C.Er,1),size(C.Er,2));
		%C.correctForEta=0; % leave at 0. trigger/detection efficiency = 1 in this analysis.
		C.correctForResolution=2;
		C.cutAcceptance = 0.99*ones(size(C.Er,1),size(C.Er,2));
		C.kg = 1.21;
		C.liveDays = 12.5;
		C.Z = 54;
		C.A = 131.3; % average
		C.t = 0.915; % minimum WIMP flux (i think)
		C.PoissonFactor = 0.22; % as determined by testPoissonConvolution.m
		switch 0
		case 0
			S{ee}.col=[0 1 0]; S{ee}.sty = '-'; S{ee}.lw = 1.0; S{ee}.leg = 'XENON10';
			load ~/matlab/sessions/110329_xenon10swansong/Er2.mat;
			eventsEr = [1.4 Er2 10];
		case 1
			S{ee}.col=[1 0 0]; S{ee}.sty = '--'; S{ee}.lw = 1.0; S{ee}.leg = 'XENON10';
			load ~/matlab/sessions/110329_xenon10swansong/Er3.mat;
			eventsEr = [1.4 Er3 10];		
		end
		m_chi = [4:0.25:5 5.5 6 6.5 7 8 9 10 11 12 14 16 20];
		C.EnergyCalibration = 'lindhardk011_Qy';
		C.Er_cutoff = 1.4; % keV

	case 300 % checking standard S1 S2 analysis
		experiment='LUX';
		limitMethod='maxGap';
		switch 2
		case 0
			experimentalRange = [4 30]; % keVr
			C.eta = ones(size(C.Er,1),size(C.Er,2));
			C.cutAcceptance = 0.5*ones(size(C.Er,1),size(C.Er,2));
			C.correctForResolution=0;
		case 1
			experimentalRange = [3 30]; % keVr
			load LUX_eta1b_10eV.mat; % assumes Er = [0.01:0.01:40]; % generated by NRbandsim
			C.eta = LUX_eta1b_10eV;
			C.cutAcceptance = ones(size(C.Er,1),size(C.Er,2));
			C.correctForResolution=0;
		case 2
			experimentalRange = [3 30]; % keVr
			load LUX_eta1b_10eV.mat; % assumes Er = [0.01:0.01:40]; % generated by NRbandsim
			C.eta = LUX_eta1b_10eV;
			C.cutAcceptance = ones(size(C.Er,1),size(C.Er,2));
			C.correctForResolution=2;
			C.PoissonFactor = 0.22;
		end

		eventsEr = [experimentalRange(1) experimentalRange(2)]
		
		
		C.kg = 118;
		C.liveDays = 88.3;
		C.Z = 54;
		C.A = 131.3; % average
		C.t = 0.49; % LUX flux
		%C.t = 0.67; % year avg WIMP flux


		S{ee}.col=[0 0 0]; S{ee}.sty = ':'; S{ee}.lw = 1.0;
		m_chi = [5:1:10 15:5:20 30:10:100];
		%m_chi = 6;

	case 6000 
		experiment='LZ'; 
		limitMethod='maxGap';
		%C.correctForEta=0; % leave at 0. trigger/detection efficiency = 1 in this analysis.
		C.eta = ones(size(C.Er,1),size(C.Er,2));
		C.cutAcceptance = ones(size(C.Er,1),size(C.Er,2));
		C.kg = 1126;% assume R<10.5 cm, => m=45 kg
		C.liveDays = 120;
		C.Z = 54;
		C.A = 131.3; % average
		C.t = 0.915; % minimum WIMP flux (i think)

		window_Er = 10; % assume searching 10 keVr window == 1-2 keVee
		%threshold_Er = 1.4; % keVr
		threshold_Er = 0.5; % keVr, lowered based on arxiv:1412.3028
		experimentalRange = threshold_Er+[0 window_Er]; % keVr

		switch 1
		case 0 % assume limited by flat gamma background
		% how many events? conservatively assume 2 keVee ==> 10 keVr	
			%bkgRate = 0.05; % dru
			%n = bkgRate * C.kg * C.liveDays * 2;
			n = 1; % based on Monica's bkg sims
			eventsEr = [experimentalRange(1) ...
				sort(rand(1,round(n))*diff(experimentalRange))+experimentalRange(1) ...
						experimentalRange(2)]
		case 1 % assume limited by neutrinos
			% calculate the 8B neutrino flux
			C = getdRdEr8B(C);
			cts8B = (C.dRdEr.*(C.Er>threshold_Er) * C.dEr * C.liveDays * C.kg);
			trial_cts8B = 0;
			%while ~inrange(sum(trial_cts8B),sum(cts8B)+[-1 +1]) % constrain total number of events
				trial_cts8B = poissrnd(cts8B); trial_cts8B = trial_cts8B.*(C.Er>threshold_Er);
			%end			
			eventsEr = experimentalRange;
			for kk=1:length(trial_cts8B)
				eventsEr = [eventsEr rand(1,trial_cts8B(kk))*C.dEr+C.Er(kk)];
			end
			% 
			if 0 % also assume 1 pp neutrino event expected
				%add_pp_events = rand(1,poissrnd(1))*10+1.4 % based on 4.6 cts/keV/tonee/year*(1.126 tonne)*(120/365 years)*(40/61 electrons)*(0.9 not able to veto fraction)
				add_pp_events = rand(1,1)*10+1.4 % based on 4.6 cts/keV/tonee/year*(1.126 tonne)*(120/365 years)*(40/61 electrons)*(0.9 not able to veto fraction)
				eventsEr = [eventsEr add_pp_events];
			end
		end
		eventsEr = sort(eventsEr);
		%[C.Er' cts8B' trial_cts8B'];
		sum([cts8B' trial_cts8B']); % make sure random fluctuations aren't screwing up total number of expected events
		
		C.correctForResolution=0;
		C.PoissonFactor = 0.22; % as determined by testPoissonConvolution.m

		S{ee}.col=[0 0 0]; S{ee}.sty = ':'; S{ee}.lw = 1.0;
		%m_chi = [4.5 5 6 7 8 10 12 ];
		%m_chi = [2:0.1:4.4 4.5:0.1:7 7.2:0.2:8 8.25:0.25:10];
		switch 1
		case 0
			m_chi = [3:0.1:4.4 4.5:0.1:7 7.2:0.2:8 8.25:0.25:10];
			sigma_n0 = 1e-43; % cm^2 
		case 1
			m_chi = [1:0.1:2.9];
			sigma_n0 = 1e-36; % cm^2 
		end		
	end

	S{ee}.experiment=experiment;
	
	inter = getIntervalCombinations(C,eventsEr);
	load yellin_fig5.mat;


%%% if not already specified, define defaults for m_chi, sigma_n0, delta
	rasterType = 1;
	switch rasterType
	case 1 % raster across m_chi
		if ~exist('deltas','var'); % then set deltas=0
			deltas = 0*1e-6;
		end
		if ~exist('m_chi','var'); % then use the default
			m_chi = [4 5 6 7 8 9 10 11 12 15 20 50 100];
		end
		if ~exist('sigma_n0','var'); % then use the default
			switch limitMethod
			case 'Poisson' % start high and drop
				sigma_n0 = 1e-36; % cm^2 
			case 'maxGap' 
				sigma_n0 = 1e-40; % cm^2 
			end
		end
	end

C.sigma_n = sigma_n0; % initialize
inter.sigma_n = sigma_n0;

%%%%%%%%%%%%%%%%%%%%%%%%% READ-ONLY below this line (unless you know what you are doing)

%% derived constants
	C.M_N = C.A*C.mp; % GeV

%% begin loop over m_chi
for hh=1:length(m_chi); % GeV
	C.m_chi = m_chi(hh);
	%%% begin loop over delta
	for ii=1:length(deltas); % MeV
		delta=deltas(ii); C.delta=delta;
		C.sigma_n = sigma_n0; % re-set to starting point
		
		jj=1; % do NOT change this
		iter=0;
		scanningForSigma_n = 1; % starting condition
		while scanningForSigma_n
			iter=iter+1;
			C = getHelmFF(C);
			C = getBetaMin(C);%%% calculate beta_min
			
			%% calculate dR_dEr for a given m_chi, delta and sigma
				dR_dEr = getdRdErDM(C);	% now outputs in dru, so next line not needed!!	
				dru = dR_dEr; % already in dru
				cts = dru * C.dEr * C.liveDays * C.kg ;					

				%% This is where detector resolution should be applied to the predicted spectrum
				switch C.correctForResolution % USE 0 unless you are sure you know what you are doing
				case 0 % no resolution correction
					ctsRes = cts;
					% Finally, apply S1 detection efficiency (eta_S1) and the cuts efficiency (epsilon_c)
					visible_ctsRes = ctsRes.*C.cutAcceptance.*C.eta;
					visible_cts = cts.*C.cutAcceptance.*C.eta;

				case 1 % simple assumption that resolution is Poisson in keV
					% apply the optional explicit keV cutoff, below which no response is generated
					%C.PoissonFactor = 1.4;
					tmp_cts=cts;
					tmp_cts(C.Er<C.Er_cutoff)=0;
					% this is the same as assuming that 1 S1 phe == 1 keVr, which is a decent 1st-order approximation
					[ctsRes] = PoissonConvolution(tmp_cts,C.Er,C.PoissonFactor);						
					% Finally, apply S1 detection efficiency (eta_S1) and the cuts efficiency (epsilon_c)
					visible_ctsRes = ctsRes.*C.cutAcceptance.*C.eta;
					visible_cts = cts.*C.cutAcceptance.*C.eta;
				case 1.1 % correct method ? NOT WORKING YET
					% (1) convert physical keV to actual phe, via Leff
					% this is done in defineExperimentForLimitCalc.m
					%	[leff,junk,C.S1]=getLeff([],whichleff,C.Ly,C.S,C.Er);								
					% (2) apply resolution to S1 bins
					
						ctsRes = zeros(size(cts));
						[ctsRes(C.S1>0)] = PoissonConvolution(cts(C.S1>0),C.S1(C.S1>0),1);
						
					%	ctsRes = 
					
					% (3) convert ctsRes back to keV by associating it with C.Er instead of C.S1
					% Finally, apply S1 detection efficiency (eta_S1) and the cuts efficiency (epsilon_c)
					C.detResponse =  0.5*(erf( (experimentalRange(2)-C.Er).*sqrt(C.S1)./sqrt(2) ) - erf( (experimentalRange(1)-C.Er).*sqrt(C.S1)./sqrt(2) ));

					visible_ctsRes = ctsRes.*C.cutAcceptance.*C.eta;%.*C.detResponse;
					visible_cts = cts.*C.cutAcceptance.*C.eta;
				case {1.2} % ALSO CORRECT - use actual bin counts from NRbandsim.m
					%C.eta(3)=0;C.eta(4)=0;
					% NN: (S1,keV)
					% apply eta FIRST, since it is in terms of keV, not keVr
					ctsRes = (sum(repmat((cts.*C.eta),size(NN,1),1).*NN(:,1:size(C.eta,2)),2))';
					% now ctsRes is in keVr.
					ctsRes = ctsRes(:,1:size(cts,2));
					%figure(12);semilogy(cts,'bo-');hold on; semilogy(ctsRes,'rs-')
					% Finally, apply cuts efficiency (epsilon_c)
					visible_ctsRes = ctsRes.*C.cutAcceptance;
					visible_cts = cts.*C.cutAcceptance;
				case 2 % S2, resolution is ~ Poisson in number of electrons
					cts(C.Er<C.Er_cutoff)=0;
					[ctsRes] = PoissonConvolution(cts,C.Er,C.PoissonFactor);						
					%ctsRes(C.Er<C.Er_cutoff)=0; % this would be redundant
					% Finally, apply S1 detection efficiency (eta_S1) and the cuts efficiency (epsilon_c)
					visible_cts = cts.*C.cutAcceptance.*C.eta;
					visible_ctsRes = ctsRes.*C.cutAcceptance.*C.eta;
				case 3
					C.detResponse =  0.5*(erf( (experimentalRange(2)-C.Er).*sqrt(C.S1)./sqrt(2) ) - erf( (experimentalRange(1)-C.Er).*sqrt(C.S1)./sqrt(2) ));
					visible_ctsRes = cts.*C.eta.*C.cutAcceptance.*C.detResponse;

				end
			
				%%% get better precision on the sum by interpolating.  must do this after Poisson convolution.
				%dErNonInteger = 0.1;
				%ErNonInteger = 0.9:dErNonInteger:50;
				%visible_ctsResNonInteger = interp1(C.Er,visible_ctsRes,ErNonInteger,'cubic',0);
				%visible_ctsResNonInteger(1) = visible_ctsResNonInteger(2); % kludge to give physical value to 0.9 keV point, which is out of range and otherwise set to 0.
			
			%% this is where the 90% CL is implemented
			switch limitMethod
			case 'Poisson'
				%Er_min = 0;% the efficiency will take care of the rest, % Er(1);
				Nevts = N90(sum(eventsEr)); % assuming no events between the first 2
				Npred = sum(visible_ctsRes(C.Er>=eventsEr(1) & C.Er<eventsEr(end)));
				%Npred = sum(visible_ctsResNonInteger(ErNonInteger>=Er_min & ErNonInteger<Er_max)) * dErNonInteger;
				if Npred > Nevts;
					C.sigma_n=C.sigma_n*granularityInSigma_n; % increase sigma_n
					dis('m_chi=%1.1f GeV\tNpred=%1.1f\tNevts=%1.1f\tsigma_n=%1.1e\t(%1.1f=>%1.1f keVr)',C.m_chi,Npred,Nevts,C.sigma_n,eventsEr(1),eventsEr(end));
				else
					scanningForSigma_n = 0;
				end
			case 'maxGap'
				iis = find(inter.n==0); % pairs with 0 events in interval
				clear C0s x mu;
				for i=iis
					%% get the expected number of events in the max gap interval (x_i):
						logi = C.Er>=inter.pair{i}(1) & C.Er<=inter.pair{i}(2);
						%if sum(logi)<3; dis('*** only %d points in sum(logi) -- (may be poorly sampled)',sum(logi)); end;
						x(i) = sum( visible_ctsRes(logi)); % expect events
					%% get the expected number of events in the full interval (mu_i):
						logi2 = C.Er>=eventsEr(1) & C.Er<=eventsEr(end);
						mu(i) = sum( visible_ctsRes(logi2));
				
					if x(i)>1e-3 % this is an error-trap for a quantization artifact
						m=floor( mu(i)/x(i) );
						if m>100 % from Yellin: "when mu is large, the series can be truncated at relatively small k without making a significant error. "
							%dis('setting m==100 (was %d)',m);
							%dis('*** m = %2.1e (problem) ***',m);
							m=100;
						end;
					else
						m=0;
					end
					
					k=0:1:m;
					if isnan(k)
						% then we can't calculate C0_pieces
						C0 = 0.900;
					else % we can
						warning off;
						C0_pieces = (k.*x(i)-mu(i)).^k .* exp(-k.*x(i)) ./ factorial(k) .* (1+k./(mu(i)-k.*x(i)));
						warning on;
						C0_pieces(isnan(C0_pieces))=-1;
						C0 = sum( C0_pieces ); % assumption is excluded at this CL
						if C0==0 & length(C0_pieces)==2 % then this is going to spiral off to infinity...
							C0=0.9;
						end
					end	
					% record for each pair
					C0s(i) = C0; 
					
				end	
				
				%dis('done w i loop');
				if any( x>(length(eventsEr)*2) ) % expecting too many events, just decrease sigma
					C.sigma_n=C.sigma_n*granularityInSigma_n; % decrease sigma_n
					dis('max(x)=%2.1f so decreasing sigma_n to %1.1e...',max(x),C.sigma_n);
				elseif any(C0s>0.9 & C0s<1)
					dis('m_chi=%1.1f\tsigma_n=%1.1e\titer=%3d',C.m_chi,C.sigma_n,iter);				
					C.sigma_n=C.sigma_n*granularityInSigma_n; % decrease sigma_n
					
				else % break out
					scanningForSigma_n = 0;
					ic=find(C0s>=0.89 & C0s<1);% which pair is doing the work
					if ~isempty(ic) & length(ic)==1
					dis('pair=%d\tEr=[%1.2f %1.2f]\tC0=%1.4f\tx=%2.1f\tmu=%2.1f',ic,inter.pair{ic}(1),inter.pair{ic}(2),C0s(ic),x(ic),mu(ic));
					else
					dis('ic is empty :) or length(ic)>1')
					end
				end
				
			end % case

			if 0%graphik==C.m_chi & scanningForSigma_n==0 %& C.sigma_n == 1e-41 %
				leg=[];hleg=[];
				figure(11);%clf;
				%subplot(2,2,1);
					h=semilogy(C.Er,cts/C.dEr/C.kg/C.liveDays,'k--','lineW',2);hleg(end+1)=h;leg{end+1}='theory';
					hold on;
					h=plotstairs(C.Er,ctsRes/C.dEr/C.kg/C.liveDays,'k-');hleg(end+1)=h;leg{end+1}='theory * resolution';
					h=plotstairs(C.Er,visible_ctsRes/C.dEr/C.kg/C.liveDays,'b-');hleg(end+1)=h;leg{end+1}='theory * resolution';
					%if C.Er_cutoff>0
					%	h=plot(C.Er_cutoff*[1 1],[ax(3) ax(4)],'k-.');hleg(end+1)=h;leg{end+1}=dis('cutoff at %2.1f keV',C.Er_cutoff);
					%end
					myFigView;
					xlabel('keV');ylabel('cts/keV/kg/day');
					if deltas(ii)==0
						title(['m_{\chi} = ' dis('%1.0f GeV',C.m_chi) ' \sigma_n = ' dis('%1.1e',C.sigma_n)]);						
					else
						title(['\delta = ' dis('%1.0f keV ...',deltas(ii)*1e6) ' m_{\chi} = ' dis('%1.0f GeV',C.m_chi) ' \sigma_n = ' dis('%1.1e',C.sigma_n)]);
					end
					
					set(gca,'ysc','log','xsc','log');
					switch 0
					case 0
						axis([1 20 1e-5 1e0]);ax=axis;
						%set(gca,'xtick',[ax(1):1:ax(2)]);set(gca,'xtickl',{'1' '2' '' '' '5' '' '' '' '' '10' '' '' '' '' '15' '' '' '' '' '20'});
						%set(gca,'ytick',10.^[log10(ax(3)):1:3]);
					case 1
						axis([1 10 1e-3 2]);ax=axis;						
						set(gca,'xtick',[ax(1):1:ax(2)]);set(gca,'xtickl',{'1' '2' '' '' '5' '' '' '' '' '10'});
					end

					drawnow;
					
			end
			
			switch rasterType
			case 1
				S{ee}.sigma_n(hh,jj) = C.sigma_n;
				S{ee}.delta = deltas*1e6;
			case 2
				S{ee}.sigma_n(ii,jj) = C.sigma_n;
				S{ee}.delta = deltas*1e6;
			end % switch rasterType
			
		end % while scanningForSigma_n (loop over jj)
	end % ii loop over delta
end % hh loop over m_chi

	S{ee}.m_chi = m_chi;
	
end % e loop

%% write text file
if 0
%fid=fopen('130426_limits.txt','w');
%fprintf(fid,'%3.2f %3.2e\n',[S{24}.m_chi' S{24}.sigma_n]');
%fclose(fid);
end

